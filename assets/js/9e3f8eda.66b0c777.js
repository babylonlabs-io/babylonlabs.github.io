"use strict";(self.webpackChunkdocument_sample=self.webpackChunkdocument_sample||[]).push([[766],{8854:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>l,frontMatter:()=>s,metadata:()=>a,toc:()=>h});var t=i(4848),o=i(8453);const s={id:"checkpointing",sidebar_label:"Checkpointing Module",hide_table_of_contents:!0},c="Checkpointing Module",a={id:"developer-guides/modules/checkpointing",title:"Checkpointing Module",description:"Learn what the Babylon Checkpointing Module is and how it operates.",source:"@site/docs/developer-guides/modules/checkpointing.md",sourceDirName:"developer-guides/modules",slug:"/developer-guides/modules/checkpointing",permalink:"/docs/developer-guides/modules/checkpointing",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/developer-guides/modules/checkpointing.md",tags:[],version:"current",frontMatter:{id:"checkpointing",sidebar_label:"Checkpointing Module",hide_table_of_contents:!0},sidebar:"docs",previous:{title:"Epoching Module",permalink:"/docs/developer-guides/modules/epoching"},next:{title:"BTC Checkpoint Module",permalink:"/docs/developer-guides/modules/btccheckpoint"}},r={},h=[{value:"Summary",id:"summary",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Design",id:"design",level:2},{value:"BLS Key Registration",id:"bls-key-registration",level:3},{value:"Sending and Processing BLS Signatures",id:"sending-and-processing-bls-signatures",level:3},{value:"Checkpoint Status Change",id:"checkpoint-status-change",level:3},{value:"Checkpoint Verification and Panicking",id:"checkpoint-verification-and-panicking",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"checkpointing-module",children:"Checkpointing Module"}),"\n",(0,t.jsx)(n.p,{children:"Learn what the Babylon Checkpointing Module is and how it operates."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsxs)(n.p,{children:["The Checkpointing module is responsible for generating and maintaining checkpoints for each epoch.\nThese checkpoints will be submitted to BTC by ",(0,t.jsx)(n.a,{href:"./submitter",children:"vigilante submitters"})," once having accumulated sufficient voting power via BLS signatures.\nThis module plays a critical role in the security story of Babylon as it produces a canonical sequence of epochs."]}),"\n",(0,t.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,t.jsxs)(n.p,{children:["Checkpointing aims to empower Babylon with BTC-level security by perpetuating the Babylon ledger on BTC.\nThe checkpointing module needs to generate a succinct checkpoint that involves sufficient voting power for each epoch.\nFor the above purpose, the Checkpointing module adopts the ",(0,t.jsx)(n.a,{href:"https://datatracker.ietf.org/doc/html/draft-boneh-bls-signature-00",children:"BLS signature scheme"})," which aggregates multiple signatures into a single signature.\nWith the help of BLS signatures, a checkpoint is fixed in size and can be converted into two BTC transactions in the ",(0,t.jsx)(n.code,{children:"OP_RETURN"})," field with a limit of 80 bytes.\nTherefore, the checkpointing module needs to handle all the messages related to BLS signatures such as signing, verifying and accumulating BLS signatures."]}),"\n",(0,t.jsx)(n.h2,{id:"design",children:"Design"}),"\n",(0,t.jsx)(n.p,{children:"The Checkpointing module makes the following design decisions:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#bls-key-registration",children:"Validator registration"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#sending-and-processing-bls-signatures",children:"Sending and processing BLS signatures"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#checkpoint-status-change",children:"Checkpoint status change"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#checkpoint-verification-and-panicking",children:"Checkpoint verification and panicking"})}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"bls-key-registration",children:"BLS Key Registration"}),"\n",(0,t.jsxs)(n.p,{children:["Each validator must register its BLS public key before voting in the Babylon network.\nEach validator can only register a unique BLS public key, which can only be registered by a unique validator.\nThe registration requires the validator to provide its BLS public key as well as proof which proves its ownership of this key (proof-of-possession, or PoP).\nThe PoP is needed to defend against ",(0,t.jsx)(n.a,{href:"https://eprint.iacr.org/2021/377.pdf",children:"rogue key attacks"}),', in which a specially crafted public key (the "rogue" key) is used to forge an aggregated signature.\nThe purpose of PoP is to prove that one validator owns the corresponding BLS private key and the corresponding Ed25519 private key associated with the public key used in Tendermint consensus.\nThe PoP is calculated as the following:']}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"PoP = sign(key = BLS_sk, data = sign(key = Ed25519_sk, data = BLS_pk)]."})}),"\n",(0,t.jsx)(n.h3,{id:"sending-and-processing-bls-signatures",children:"Sending and Processing BLS Signatures"}),"\n",(0,t.jsxs)(n.p,{children:["The Checkpointing module is initiated with a BLS signer which signs a BLS signature at each epoch boundary and sends it to Tendermint for consensus.\nThe signature is signed over ",(0,t.jsx)(n.code,{children:"epoch_number"})," concatenated with ",(0,t.jsx)(n.code,{children:"last_commit_hash"})," obtained from the epoch boundary block's ",(0,t.jsx)(n.a,{href:"https://github.com/tendermint/spec/blob/8dd2ed4c6fe12459edeb9b783bdaaaeb590ec15c/spec/core/data_structures.md",children:"header"}),".\nUpon receiving a BLS signature transaction, the Checkpointing module accumulates the voting power of the signature for a specific epoch.\nOnce sufficient signatures are accumulated (e.g., > 1/3 in terms of voting power),\nthe checkpoint will become ",(0,t.jsx)(n.code,{children:"SEALED"})," and no longer accumulate new signatures."]}),"\n",(0,t.jsx)(n.h3,{id:"checkpoint-status-change",children:"Checkpoint Status Change"}),"\n",(0,t.jsxs)(n.p,{children:["Checkpoints are maintained by the checkpointing module with five statuses: ",(0,t.jsx)(n.code,{children:"ACCUMULATING"}),", ",(0,t.jsx)(n.code,{children:"SEALED"}),", ",(0,t.jsx)(n.code,{children:"SUBMITTED"}),", ",(0,t.jsx)(n.code,{children:"CONFIRMED"}),", and ",(0,t.jsx)(n.code,{children:"FINALIZED"}),".\nWe describe the checkpoint status change as below."]}),"\n",(0,t.jsxs)(n.p,{children:["At each epoch boundary, the Checkpointing module generates an empty checkpoint of this epoch with ",(0,t.jsx)(n.code,{children:"ACCUMULATING"}),".\nOnce it accumulates sufficient voting power, the checkpoint changes the status to ",(0,t.jsx)(n.code,{children:"SEALED"}),", waiting for a ",(0,t.jsx)(n.a,{href:"./submitter",children:"vigilante submitter"})," to submit it to BTC.\nWhen a valid checkpoint is reported back to Babylon, meaning that the checkpoint has been submitted to BTC, the status of the checkpoint is changed to ",(0,t.jsx)(n.code,{children:"SUBMITTED"}),".\nIf a ",(0,t.jsx)(n.code,{children:"SUBMITTED"})," checkpoint is observed on a forked BTC chain (non-canonical chain), the status will be reverted back to ",(0,t.jsx)(n.code,{children:"SEALED"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["When a checkpoint receives sufficient confirmations (e.g., k-deep) on the BTC header chain maintained by the ",(0,t.jsx)(n.code,{children:"btclightclient"})," module, its status will be changed to ",(0,t.jsx)(n.code,{children:"CONFIRMED"}),".\nSimilarly, as the header chain grows, a checkpoint will eventually change its status to ",(0,t.jsx)(n.code,{children:"FINALIZED"})," when more confirmations are received (e.g., up to w-deep).\nThe last three statuses are controlled by the ",(0,t.jsx)(n.code,{children:"btccheckpoint"})," module and the ",(0,t.jsx)(n.code,{children:"btclightclient"})," as the Checkpointing module requires BTC information from them."]}),"\n",(0,t.jsx)(n.h3,{id:"checkpoint-verification-and-panicking",children:"Checkpoint Verification and Panicking"}),"\n",(0,t.jsxs)(n.p,{children:["The Checkpointing module verifies raw checkpoints reported from BTC to Babylon by a ",(0,t.jsx)(n.a,{href:"./reporter",children:"vigilante reporter"}),".\nReported checkpoints are first processed by the ",(0,t.jsx)(n.code,{children:"btccheckpoint"})," module for decoding and then sent to the Checkpointing module for verification.\nThe verification workflow is as the following:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"check whether the BLS signature of the checkpoint is valid,"}),"\n",(0,t.jsx)(n.li,{children:"check whether the BLS signature has accumulated sufficient voting power, and"}),"\n",(0,t.jsxs)(n.li,{children:["check whether the signed ",(0,t.jsx)(n.code,{children:"last_commit_hash"})," of the checkpoint equals to that of the corresponding checkpoint at the same epoch stored locally."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Step 3 is a critical step to detect forks. If Step 1 and Step 2 pass but Step 3 does not, it means that a fork exists and the validator should panic."})]})}function l(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>c,x:()=>a});var t=i(6540);const o={},s=t.createContext(o);function c(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);