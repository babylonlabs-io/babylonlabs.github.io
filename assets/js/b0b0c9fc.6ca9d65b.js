"use strict";(self.webpackChunkdocument_sample=self.webpackChunkdocument_sample||[]).push([[9814],{2829:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>d});var o=n(4848),t=n(8453);const s={id:"btccheckpoint",sidebar_label:"BTC Checkpoint Module",hide_table_of_contents:!0},c="BTC Checkpoint Module",r={id:"developer-guides/modules/btccheckpoint",title:"BTC Checkpoint Module",description:"Learn what the Babylon BTC Checkpoint Module is and how it operates.",source:"@site/docs/developer-guides/modules/btccheckpoint.md",sourceDirName:"developer-guides/modules",slug:"/developer-guides/modules/btccheckpoint",permalink:"/docs/developer-guides/modules/btccheckpoint",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/developer-guides/modules/btccheckpoint.md",tags:[],version:"current",frontMatter:{id:"btccheckpoint",sidebar_label:"BTC Checkpoint Module",hide_table_of_contents:!0},sidebar:"docs",previous:{title:"Checkpointing Module",permalink:"/docs/developer-guides/modules/checkpointing"},next:{title:"BTC Light Client Module",permalink:"/docs/developer-guides/modules/btclightclient"}},a={},d=[{value:"Summary",id:"summary",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Submission Identification",id:"submission-identification",level:3},{value:"Submission Validation Rules",id:"submission-validation-rules",level:3}];function l(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.h1,{id:"btc-checkpoint-module",children:"BTC Checkpoint Module"}),"\n",(0,o.jsx)(i.p,{children:"Learn what the Babylon BTC Checkpoint Module is and how it operates."}),"\n",(0,o.jsx)(i.hr,{}),"\n",(0,o.jsx)(i.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsxs)(i.p,{children:["The ",(0,o.jsx)(i.code,{children:"btccheckpoint"})," module is responsible for receiving information about Babylon checkpoints\nsubmitted to Bitcoin ledger. Each valid submission is composed of two Bitcoin transactions.\nEach of those transactions must contain at least one OP_RETRUN output which contains specific\nBabylon data. To verify that those transactions are part of bitcoin ledger, each submission\nmust also have merkle proof of inclusions against transaction root hash from Bitcoin\nheader which is already known by ",(0,o.jsx)(i.code,{children:"btclightclient"})," module.\nData included in OP_RETURN outputs must form a valid Babylon checkpoint. As ",(0,o.jsx)(i.code,{children:"btccheckpoint"}),"\ndoes not know all rules which makes checkpoint valid, it communicates with\n",(0,o.jsx)(i.code,{children:"checkpoint"})," module to validate it.\nAfter submission is deemed valid:"]}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:["It stored and tracked by ",(0,o.jsx)(i.code,{children:"btcheckpoint"})," module"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"checkpointing"})," module is informed about the different stages of checkpoint life cycle"]}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,o.jsxs)(i.p,{children:["To properly track the life cycle of checkpoint on Bitcoin ledger, ",(0,o.jsx)(i.code,{children:"btccheckpoint"})," module\nrelay on two external processes:"]}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"vigilante submitter - process which submits checkpoints from Babylon network to Bitcoin\nnetwork"}),"\n",(0,o.jsx)(i.li,{children:"vigilante reporter - process which scan Bitcoin ledger looking for Babylon checkpoints\nand reports them back to Babylon.\nAs Babylon is open system, there can be many submitters and many reporters which can\nlead to (if submitters and reporters do not coordinate):"}),"\n",(0,o.jsx)(i.li,{children:"submitting one checkpoint multiple times on Bitcoin ledger by different submitters"}),"\n",(0,o.jsxs)(i.li,{children:["reporting one submission multiple times to Babylon by different reporters\n",(0,o.jsx)(i.code,{children:"btccheckpoint"})," module need to take care of properly de-duplicating identical submissions\nand deciding which submission is first on Bitcoin ledger."]}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"submission-identification",children:"Submission Identification"}),"\n",(0,o.jsxs)(i.p,{children:["Each submitted transaction is identified by ",(0,o.jsx)(i.code,{children:"TransactionKey"}),"  which is composed from\nBitcoin block header hash and transaction index in the block, and each submission\nis identified by ",(0,o.jsx)(i.code,{children:"SubmissionKey"})," which composed from two ",(0,o.jsx)(i.code,{children:"TransactionKeys"}),". Submission\nvalidation rules makes sure that there is only one order of ",(0,o.jsx)(i.code,{children:"TransactionKeys"})," in each\nsubmissions.\nThis layout makes it easy to not accept submissions if it was already reported and recorded\nin Babylon ledger."]}),"\n",(0,o.jsx)(i.h3,{id:"submission-validation-rules",children:"Submission Validation Rules"}),"\n",(0,o.jsxs)(i.p,{children:["Each submission is inserted into Babylon ledger by sending transaction which contains\n",(0,o.jsx)(i.code,{children:"MsgInsertBTCSpvProof"})," ",(0,o.jsx)(i.a,{href:"https://github.com/babylonlabs-io/babylon/blob/dev/proto/babylon/btccheckpoint/tx.proto#L15",children:"msg"}),".\nThis message must contain all necessary data required to validate that submissions is part of\nBitcoin canonical chain. Message must contain two ",(0,o.jsx)(i.a,{href:"https://github.com/babylonlabs-io/babylon/blob/dev/proto/babylon/btccheckpoint/btccheckpoint.proto#L23",children:"BTCSpvProof"})," objects.\nEach ",(0,o.jsx)(i.code,{children:"BTCSpvProof"})," contains:"]}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Bitcoin transaction"}),"\n",(0,o.jsx)(i.li,{children:"Index of Bitcoin transaction in Bitcoin block"}),"\n",(0,o.jsx)(i.li,{children:"merkle proof that provided transaction is part of the Bitcoin block"}),"\n",(0,o.jsx)(i.li,{children:"Bitcoin header of the block which contains provided transaction."}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"Validations performed when receiving new submission:"}),"\n",(0,o.jsxs)(i.ol,{children:["\n",(0,o.jsx)(i.li,{children:"Check that all received Bitcoin objects (Transactions, Headers, Proofs) have correct format"}),"\n",(0,o.jsx)(i.li,{children:"Check that merkle proofs are connecting provided transactions to provided headers"}),"\n",(0,o.jsx)(i.li,{children:"Check that provided transactions contain OP_RETRUN outputs which contains data"}),"\n",(0,o.jsx)(i.li,{children:"Check that data extracted from OP_RETURN outputs form possible Babylon checkpoint."}),"\n",(0,o.jsx)(i.li,{children:"Check that submission is not a duplicate"}),"\n",(0,o.jsxs)(i.li,{children:["Check that provided Bitcoin headers are known to ",(0,o.jsx)(i.code,{children:"btclightclient"})," module and are\non the Bitcoin main chain maintained by ",(0,o.jsx)(i.code,{children:"btclightclient"})," module"]}),"\n",(0,o.jsxs)(i.li,{children:["Check that extracted checkpoint is valid, according to ",(0,o.jsx)(i.code,{children:"checkpointing"})," module rules"]}),"\n",(0,o.jsx)(i.li,{children:"Check that that there are already valid checkpoint submissions for checkpoints for the previous epoch which\nare deeper in Bitcoin ledger.\nExample: If the received checkpoint is for epoch 9 and is in Bitcoin block which is 10 deep on Bitcoin\nledger, there must already exists submission for epoch 8 which is at least 11 deep on Bitcoin ledger.\nThis rule ensures that checkpoints for older epoch, are older on Bitcoin chain."}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,o.jsx)(i,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>c,x:()=>r});var o=n(6540);const t={},s=o.createContext(t);function c(e){const i=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),o.createElement(s.Provider,{value:i},e.children)}}}]);