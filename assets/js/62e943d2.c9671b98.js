"use strict";(self.webpackChunkdocument_sample=self.webpackChunkdocument_sample||[]).push([[84],{662:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>h});var r=n(4848),o=n(8453);const i={id:"reporter",sidebar_label:"Vigilante Reporter Program",hide_table_of_contents:!0},a="Vigilante Reporter",s={id:"developer-guides/vigilantes/reporter",title:"Vigilante Reporter",description:"Learn what the Babylon Vigilante Reporter program is and how it operates.",source:"@site/docs/developer-guides/vigilantes/reporter.md",sourceDirName:"developer-guides/vigilantes",slug:"/developer-guides/vigilantes/reporter",permalink:"/docs/developer-guides/vigilantes/reporter",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/developer-guides/vigilantes/reporter.md",tags:[],version:"current",frontMatter:{id:"reporter",sidebar_label:"Vigilante Reporter Program",hide_table_of_contents:!0},sidebar:"docs",previous:{title:"Vigilante Submitter Program",permalink:"/docs/developer-guides/vigilantes/submitter"},next:{title:"Checkpointing Monitor Program",permalink:"/docs/developer-guides/vigilantes/monitor"}},c={},h=[{value:"Summary",id:"summary",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Design",id:"design",level:2},{value:"Bootstrapping",id:"bootstrapping",level:3},{value:"Forwarding Headers/Checkpoints",id:"forwarding-headerscheckpoints",level:3}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"vigilante-reporter",children:"Vigilante Reporter"}),"\n",(0,r.jsx)(t.p,{children:"Learn what the Babylon Vigilante Reporter program is and how it operates."}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(t.p,{children:"The vigilante reporter is a separate program that is responsible for forwarding headers and checkpoints from BTC to Babylon.\nUpon a new BTC block, the reporter extracts the block header and the checkpoint (if there is one) from it, wrap them in transactions and send them to Babylon.\nIt is a critical piece to ensure the liveness of Babylon as it keeps the BTC header chain of Babylon to grow.\nWe need to ensure that at least one reporter is working in the Babylon network."}),"\n",(0,r.jsx)(t.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,r.jsx)(t.p,{children:"The vigilante reporter needs to continuously processes BTC blocks from the BTC height at which the Babylon checkpointing starts.\nIt needs to forward all the BTC headers on the canonical chain to feed the BTC header chain of Babylon.\nThe reporter also needs to check every transaction in a BTC block and tries to match raw checkpoints since a raw checkpoint is decoded into two different BTC transactions."}),"\n",(0,r.jsx)(t.h2,{id:"design",children:"Design"}),"\n",(0,r.jsx)(t.p,{children:"The vigilante reporter program makes the following design decisions:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#bootstrapping",children:"Bootstrapping"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#forwarding-headerscheckpoints",children:"Forwarding Headers/Checkpoints"})}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"bootstrapping",children:"Bootstrapping"}),"\n",(0,r.jsx)(t.p,{children:"When a vigilant reporter is started, it needs to go through the bootstrapping process, which makes the following design decisions:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"BTC header synchronisation"}),": Babylon\u2019s BTC header chain is synchronised with the BTC full node that connects to vigilante.\nIf the BTC header chain of Babylon falls behind the BTC full node, the bootstrapping helps the header chain catch up.\nOn the other hand, if the header chain is ahead of the BTC full node, the reporter will wait until the BTC full node to catch up."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Header consistency"}),": Babylon\u2019s ",(0,r.jsx)(t.code,{children:"k-deep"})," BTC headers are consistent with the BTC full node"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Checkpoint synchronisation"}),": historical checkpoints on BTC are reported to Babylon.\nThe reporter sends checkpoints that are not ",(0,r.jsx)(t.code,{children:"w-deep"})," yet in BTC to Babylon.\nThe reporter also buffers all the checkpoint parts that have not been matched with a checkpoint."]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"forwarding-headerscheckpoints",children:"Forwarding Headers/Checkpoints"}),"\n",(0,r.jsxs)(t.p,{children:["After the reporter is bootstrapped, it subscribes new BTC block events via a websocket (btcd backend) or ZeroMQ (bitcoind backend).\nUpon a new BTC block, the reporter extracts the header and sends the header to Babylon.\nIn the meantime, it checks every transaction in a block and extracts checkpoint parts if there are any.\nRecall that a raw checkpoint is split into the ",(0,r.jsx)(t.code,{children:"OP_RETURN"})," field of two BTC transactions.\nTherefore, once a checkpoint part is extracted from a transaction, it will be first buffered into a ",(0,r.jsx)(t.code,{children:"checkpoint segment pool"})," and a raw checkpoint will be popped if there is a match.\nOnce a whole checkpoint is found, the reporter wraps it along with relevant Merkle proof into a transaction and send it to Babylon."]})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>s});var r=n(6540);const o={},i=r.createContext(o);function a(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);