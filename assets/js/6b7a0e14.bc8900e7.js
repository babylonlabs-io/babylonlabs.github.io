"use strict";(self.webpackChunkdocument_sample=self.webpackChunkdocument_sample||[]).push([[1706],{3003:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var i=n(4848),s=n(8453);const o={id:"submitter",sidebar_label:"Vigilante Submitter Program",hide_table_of_contents:!0},r="Vigilante Submitter",a={id:"developer-guides/modules/submitter",title:"Vigilante Submitter",description:"Learn what the Babylon Vigilante Submitter program is and how it operates.",source:"@site/docs/developer-guides/modules/submitter.md",sourceDirName:"developer-guides/modules",slug:"/developer-guides/modules/submitter",permalink:"/docs/developer-guides/modules/submitter",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/developer-guides/modules/submitter.md",tags:[],version:"current",frontMatter:{id:"submitter",sidebar_label:"Vigilante Submitter Program",hide_table_of_contents:!0}},c={},l=[{value:"Summary",id:"summary",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Design",id:"design",level:2},{value:"Extracting Checkpoints",id:"extracting-checkpoints",level:3},{value:"Converting Checkpoints to BTC Transactions",id:"converting-checkpoints-to-btc-transactions",level:3}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"vigilante-submitter",children:"Vigilante Submitter"}),"\n",(0,i.jsx)(t.p,{children:"Learn what the Babylon Vigilante Submitter program is and how it operates."}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(t.p,{children:"The vigilante submitter is a separate program that is responsible for submitting checkpoints from Babylon to BTC periodically.\nTo submit a checkpoint to Bitcoin, the Babylon system needs to encode a checkpoint to two transactions and submit them to BTC.\nIt is a critical piece to ensure the liveness of Babylon.\nWe need to ensure that at least one submitter is working in the Babylon network."}),"\n",(0,i.jsx)(t.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,i.jsxs)(t.p,{children:["The vigilante submitter needs to convert a raw checkpoint to BTC transactions and send them to BTC.\nIt also needs to ensure that all the ",(0,i.jsx)(t.code,{children:"SEALED"})," checkpoints will be eventually submitted to BTC.\nFurther, since submitting checkpoints costs real Bitcoin to pay the miners, the submitter needs to minimize the cost and duplicate submissions."]}),"\n",(0,i.jsx)(t.h2,{id:"design",children:"Design"}),"\n",(0,i.jsx)(t.p,{children:"The vigilante submitter program makes the following design decisions:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#extracting-checkpoints",children:"Extracting Checkpoints"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#converting-checkpoints-to-btc-transactions",children:"Converting Checkpoints to BTC Transactions"})}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"extracting-checkpoints",children:"Extracting Checkpoints"}),"\n",(0,i.jsxs)(t.p,{children:["In case of any failure, a checkpoint may not be successfully submitted to BTC in one shot.\nTo ensure a raw checkpoint will be eventually submitted to BTC, the submitter adopts a pull-based approach to repetitively submit checkpoints with the status of ",(0,i.jsx)(t.code,{children:"SEALED"})," even though they have been submitted before.\nThe submitter uses two configurable items, ",(0,i.jsx)(t.code,{children:"pulling-intervals"})," and ",(0,i.jsx)(t.code,{children:"resend-intervals"})," to control the frequency of the pulling and re-sending checkpoints that have been sent before."]}),"\n",(0,i.jsx)(t.h3,{id:"converting-checkpoints-to-btc-transactions",children:"Converting Checkpoints to BTC Transactions"}),"\n",(0,i.jsxs)(t.p,{children:["BTC allows users to store arbitrary data in the Bitcoin blockchain via ",(0,i.jsx)(t.code,{children:"OP_RETURN"}),", which is a transaction output in Bitcoin that is provably unspendable.\nTo avoid abuse of ",(0,i.jsx)(t.code,{children:"OP_RETURN"}),", the data size carried in ",(0,i.jsx)(t.code,{children:"OP_RETURN"})," is limited to less than 80 bytes."]}),"\n",(0,i.jsxs)(t.p,{children:["A raw checkpoint consists of ",(0,i.jsx)(t.code,{children:"epoch_num"})," (8 bytes), ",(0,i.jsx)(t.code,{children:"last_commit_hash"})," (32 bytes), ",(0,i.jsx)(t.code,{children:"bitmap"})," (13 bytes), and ",(0,i.jsx)(t.code,{children:"bls_multi_sig"})," (48 bytes), which is 101 bytes.\nBesides a raw checkpoint, the checkpoint data includes\na Babylon identifier (4 bytes) and the submitter's Babylon address (20 bytes).\nWhile this address is not used for any purposes at the moment, it could be used\nin future upgrades to potentially reward vigilante submitters for the\nsubmission."]}),"\n",(0,i.jsxs)(t.p,{children:["Therefore, we need at least two BTC transactions to carry a raw checkpoint.\nThe structure of the two ",(0,i.jsx)(t.code,{children:"OP_RETURN"})," entries is shown as the following:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-protobuf",children:"// 73 Bytes in total\nmessage CheckpointFirst {\n  int32 identifier = 0x62626E00 // 4-Byte identifier (0x62626E = BBN in text, 0x00 signals the first half)\n  uint64 epoch_num // 4 Bytes, big endian\n  bytes last_commit_hash // 32 Bytes\n  bytes bitmap // 13 Bytes\n  bytes bbn_addr // 20 bytes (for reward)\n}\n\n// 62 Bytes in total\nmessage CheckpointSecond {\n  int32 identifier = 0x62626E01 // 4-Byte identifier (0x62626E = BBN in text, 0x01 denotes the second half)\n  bytes bls_multi_sig // 48 Bytes\n  bytes checksum // first 10 Bytes of the Sha256 hash of CheckpointFirst\n}\n"})})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var i=n(6540);const s={},o=i.createContext(s);function r(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);