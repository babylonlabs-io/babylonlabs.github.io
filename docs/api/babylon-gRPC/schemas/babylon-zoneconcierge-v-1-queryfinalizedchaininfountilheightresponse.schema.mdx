---
id: babylon-zoneconcierge-v-1-queryfinalizedchaininfountilheightresponse
title: "babylon.zoneconcierge.v1.QueryFinalizedChainInfoUntilHeightResponse"
description: "QueryFinalizedChainInfoUntilHeightResponse is response type for the"
sidebar_label: "babylon.zoneconcierge.v1.QueryFinalizedChainInfoUntilHeightResponse"
hide_title: true
hide_table_of_contents: true
schema: true
sample: {"btc_submission_key":{"key":[{"hash":"string","index":0}]},"epoch_info":{"current_epoch_interval":"string","epoch_number":"string","first_block_height":"string","last_block_time":"2024-07-29T15:51:28.071Z","sealer_app_hash":"string","sealer_block_hash":"string"},"finalized_chain_info":{"consumer_id":"string","latest_forks":{"headers":[{"babylon_epoch":"string","babylon_header_hash":"string","babylon_header_height":"string","babylon_tx_hash":"string","consumer_id":"string","hash":"string","height":"string","time":"2024-07-29T15:51:28.071Z"}]},"latest_header":{"babylon_epoch":"string","babylon_header_hash":"string","babylon_header_height":"string","babylon_tx_hash":"string","consumer_id":"string","hash":"string","height":"string","time":"2024-07-29T15:51:28.071Z"},"timestamped_headers_count":"string"},"proof":{"proof_cz_header_in_epoch":{"ops":[{"data":"string","key":"string","type":"string"}]},"proof_epoch_sealed":{"proof_epoch_info":{"ops":[{"data":"string","key":"string","type":"string"}]},"proof_epoch_val_set":{"ops":[{"data":"string","key":"string","type":"string"}]},"validator_set":[{"bls_pub_key":"string","validator_address":"string","voting_power":"string"}]},"proof_epoch_submitted":[{"key":{"hash":"string","index":0},"proof":"string","transaction":"string"}]},"raw_checkpoint":{"bitmap":"string","block_hash":"string","bls_multi_sig":"string","epoch_num":"string"}}
custom_edit_url: null
---

import Schema from "@theme/Schema";
import Heading from "@theme/Heading";

<Heading
  as={"h1"}
  className={"openapi__heading"}
  children={"babylon.zoneconcierge.v1.QueryFinalizedChainInfoUntilHeightResponse"}
>
</Heading>



QueryFinalizedChainInfoUntilHeightResponse is response type for the
Query/FinalizedChainInfoUntilHeight RPC method.

<Schema
  schema={{"description":"QueryFinalizedChainInfoUntilHeightResponse is response type for the\nQuery/FinalizedChainInfoUntilHeight RPC method.","properties":{"btc_submission_key":{"properties":{"key":{"items":{"properties":{"hash":{"format":"byte","type":"string"},"index":{"format":"int64","type":"integer"}},"title":"Each provided OP_RETURN transaction can be identified by hash of block in\nwhich transaction was included and transaction index in the block","type":"object"},"type":"array"}},"title":"btc_submission_key is position of two BTC txs that include the raw\ncheckpoint of this epoch","type":"object"},"epoch_info":{"properties":{"current_epoch_interval":{"format":"uint64","title":"current_epoch_interval is the epoch interval at the time of this epoch","type":"string"},"epoch_number":{"format":"uint64","title":"epoch_number is the number of this epoch","type":"string"},"first_block_height":{"format":"uint64","title":"first_block_height is the height of the first block in this epoch","type":"string"},"last_block_time":{"description":"last_block_time is the time of the last block in this epoch.\nBabylon needs to remember the last header's time of each epoch to complete\nunbonding validators/delegations when a previous epoch's checkpoint is\nfinalised. The last_block_time field is nil in the epoch's beginning, and\nis set upon the end of this epoch.","format":"date-time","type":"string"},"sealer_app_hash":{"format":"byte","title":"sealer is the last block of the sealed epoch\nsealer_app_hash points to the sealer but stored in the 1st header\nof the next epoch","type":"string"},"sealer_block_hash":{"format":"byte","title":"sealer_block_hash is the hash of the sealer\nthe validator set has generated a BLS multisig on the hash,\ni.e., hash of the last block in the epoch","type":"string"}},"title":"epoch_info is the metadata of the last BTC-finalised epoch","type":"object"},"finalized_chain_info":{"properties":{"consumer_id":{"title":"consumer_id is the ID of the consumer","type":"string"},"latest_forks":{"description":"Forks is a list of non-canonical `IndexedHeader`s at the same height.\nFor example, assuming the following blockchain\n```\nA <- B <- C <- D <- E\n           \\ -- D1\n           \\ -- D2\n```\nThen the fork will be {[D1, D2]} where each item is in struct `IndexedBlock`.\n\nNote that each `IndexedHeader` in the fork should have a valid quorum\ncertificate. Such forks exist since Babylon considers CZs might have\ndishonest majority. Also note that the IBC-Go implementation will only\nconsider the first header in a fork valid, since the subsequent headers\ncannot be verified without knowing the validator set in the previous header.","properties":{"headers":{"items":{"properties":{"babylon_epoch":{"format":"uint64","title":"epoch is the epoch number of this header on Babylon ledger","type":"string"},"babylon_header_hash":{"format":"byte","title":"babylon_header_hash is the hash of the babylon block that includes this CZ\nheader","type":"string"},"babylon_header_height":{"format":"uint64","title":"babylon_header_height is the height of the babylon block that includes this CZ\nheader","type":"string"},"babylon_tx_hash":{"format":"byte","title":"babylon_tx_hash is the hash of the tx that includes this header\n(babylon_block_height, babylon_tx_hash) jointly provides the position of\nthe header on Babylon ledger","type":"string"},"consumer_id":{"title":"consumer_id is the unique ID of the consumer","type":"string"},"hash":{"format":"byte","title":"hash is the hash of this header","type":"string"},"height":{"format":"uint64","title":"height is the height of this header on CZ ledger\n(hash, height) jointly provides the position of the header on CZ ledger","type":"string"},"time":{"format":"date-time","title":"time is the timestamp of this header on CZ ledger\nit is needed for CZ to unbond all mature validators/delegations\nbefore this timestamp when this header is BTC-finalised","type":"string"}},"title":"IndexedHeader is the metadata of a CZ header","type":"object"},"title":"blocks is the list of non-canonical indexed headers at the same height","type":"array"}},"title":"latest_forks is the latest forks, formed as a series of IndexedHeader (from\nlow to high)","type":"object"},"latest_header":{"properties":{"babylon_epoch":{"format":"uint64","title":"epoch is the epoch number of this header on Babylon ledger","type":"string"},"babylon_header_hash":{"format":"byte","title":"babylon_header_hash is the hash of the babylon block that includes this CZ\nheader","type":"string"},"babylon_header_height":{"format":"uint64","title":"babylon_header_height is the height of the babylon block that includes this CZ\nheader","type":"string"},"babylon_tx_hash":{"format":"byte","title":"babylon_tx_hash is the hash of the tx that includes this header\n(babylon_block_height, babylon_tx_hash) jointly provides the position of\nthe header on Babylon ledger","type":"string"},"consumer_id":{"title":"consumer_id is the unique ID of the consumer","type":"string"},"hash":{"format":"byte","title":"hash is the hash of this header","type":"string"},"height":{"format":"uint64","title":"height is the height of this header on CZ ledger\n(hash, height) jointly provides the position of the header on CZ ledger","type":"string"},"time":{"format":"date-time","title":"time is the timestamp of this header on CZ ledger\nit is needed for CZ to unbond all mature validators/delegations\nbefore this timestamp when this header is BTC-finalised","type":"string"}},"title":"IndexedHeader is the metadata of a CZ header","type":"object"},"timestamped_headers_count":{"format":"uint64","title":"timestamped_headers_count is the number of timestamped headers in CZ's\ncanonical chain","type":"string"}},"title":"ChainInfo is the information of a CZ","type":"object"},"proof":{"properties":{"proof_cz_header_in_epoch":{"properties":{"ops":{"items":{"properties":{"data":{"format":"byte","type":"string"},"key":{"format":"byte","type":"string"},"type":{"type":"string"}},"title":"ProofOp defines an operation used for calculating Merkle root\nThe data could be arbitrary format, providing nessecary data\nfor example neighbouring node hash","type":"object"},"type":"array"}},"title":"proof_cz_header_in_epoch is the proof that the CZ header is timestamped\nwithin a certain epoch","type":"object"},"proof_epoch_sealed":{"properties":{"proof_epoch_info":{"properties":{"ops":{"items":{"properties":{"data":{"format":"byte","type":"string"},"key":{"format":"byte","type":"string"},"type":{"type":"string"}},"title":"ProofOp defines an operation used for calculating Merkle root\nThe data could be arbitrary format, providing nessecary data\nfor example neighbouring node hash","type":"object"},"type":"array"}},"title":"proof_epoch_info is the Merkle proof that the epoch's metadata is committed\nto `app_hash` of the sealer header","type":"object"},"proof_epoch_val_set":{"properties":{"ops":{"items":{"properties":{"data":{"format":"byte","type":"string"},"key":{"format":"byte","type":"string"},"type":{"type":"string"}},"title":"ProofOp defines an operation used for calculating Merkle root\nThe data could be arbitrary format, providing nessecary data\nfor example neighbouring node hash","type":"object"},"type":"array"}},"title":"proof_epoch_info is the Merkle proof that the epoch's validator set is\ncommitted to `app_hash` of the sealer header","type":"object"},"validator_set":{"items":{"properties":{"bls_pub_key":{"format":"byte","title":"bls_pub_key is the BLS public key of the validator","type":"string"},"validator_address":{"title":"validator_address is the address of the validator","type":"string"},"voting_power":{"format":"uint64","title":"voting_power is the voting power of the validator at the given epoch","type":"string"}},"title":"ValidatorWithBlsKey couples validator address, voting power, and its bls\npublic key","type":"object"},"title":"validator_set is the validator set of the sealed epoch\nThis validator set has generated a BLS multisig on `app_hash` of\nthe sealer header","type":"array"}},"title":"proof_epoch_sealed is the proof that the epoch is sealed","type":"object"},"proof_epoch_submitted":{"items":{"properties":{"key":{"description":"key is the position (txIdx, blockHash) of this tx on BTC blockchain\nAlthough it is already a part of SubmissionKey, we store it here again\nto make TransactionInfo self-contained.\nFor example, storing the key allows TransactionInfo to not relay on\nthe fact that TransactionInfo will be ordered in the same order as\nTransactionKeys in SubmissionKey.","properties":{"hash":{"format":"byte","type":"string"},"index":{"format":"int64","type":"integer"}},"title":"Each provided OP_RETURN transaction can be identified by hash of block in\nwhich transaction was included and transaction index in the block","type":"object"},"proof":{"format":"byte","title":"proof is the Merkle proof that this tx is included in the position in `key`\nTODO: maybe it could use here better format as we already processed and\nvalidated the proof?","type":"string"},"transaction":{"format":"byte","title":"transaction is the full transaction in bytes","type":"string"}},"title":"TransactionInfo is the info of a tx on Bitcoin,\nincluding\n- the position of the tx on BTC blockchain\n- the full tx content\n- the Merkle proof that this tx is on the above position","type":"object"},"title":"proof_epoch_submitted is the proof that the epoch's checkpoint is included\nin BTC ledger It is the two TransactionInfo in the best (i.e., earliest)\ncheckpoint submission","type":"array"}},"title":"proof is the proof that the chain info is finalized","type":"object"},"raw_checkpoint":{"properties":{"bitmap":{"format":"byte","title":"bitmap defines the bitmap that indicates the signers of the BLS multi sig","type":"string"},"block_hash":{"format":"byte","title":"block_hash defines the 'BlockID.Hash', which is the hash of\nthe block that individual BLS sigs are signed on","type":"string"},"bls_multi_sig":{"format":"byte","title":"bls_multi_sig defines the multi sig that is aggregated from individual BLS\nsigs","type":"string"},"epoch_num":{"format":"uint64","title":"epoch_num defines the epoch number the raw checkpoint is for","type":"string"}},"title":"raw_checkpoint is the raw checkpoint of this epoch","type":"object"}},"type":"object","title":"babylon.zoneconcierge.v1.QueryFinalizedChainInfoUntilHeightResponse"}}
  schemaType={"response"}
>
  
</Schema>
            